package generator

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"go.uber.org/multierr"
)

var funcs = template.FuncMap{
	"camel": strcase.ToCamel,
}

type Generator struct {
	schema *ApiSchema
	tmpl   *template.Template
}

func NewGenerator(schemaFile, tempaltesDir string) (*Generator, error) {
	file, err := os.Open(schemaFile)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var schema ApiSchema
	err = json.NewDecoder(file).Decode(&schema)
	if err != nil {
		return nil, err
	}

	tmpl := template.New("").Funcs(funcs)

	tmpl, err = tmpl.ParseGlob(filepath.Join(tempaltesDir, "*.tmpl"))
	if err != nil {
		return nil, err
	}
	return &Generator{schema: &schema, tmpl: tmpl}, nil
}

func (g *Generator) Generate(outDir string) error {
	err := os.MkdirAll(outDir, os.ModePerm)
	if err != nil {
		return err
	}

	for _, tmpl := range g.tmpl.Templates() {
		name := strings.TrimSuffix(tmpl.Name(), ".tmpl")
		if name == "" {
			// main template
			continue
		}
		outName := filepath.Join(outDir, name+".go")
		log.Printf("Generating template %s", outName)
		out, err := os.Create(outName)
		if err != nil {
			return err
		}

		// TODO
		head := fmt.Sprintf("//Generated by %s\npackage %s\n", os.Args, "api")

		data := struct {
			Head string
			*ApiSchema
		}{Head: head, ApiSchema: g.schema}

		errExecute := tmpl.Execute(out, data)
		errClose := out.Close()
		if errExecute != nil || errClose != nil {
			return multierr.Append(errExecute, errClose)
		}
	}
	return nil
}
