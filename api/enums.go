// Generated by: go run github.com/Feresey/gen-tgbotapi/cmd/generator -t ./generator/tempaltes -o api -s ./schema/public/all.json

package api

type ErrIncorrectEnum struct {
	Value string
}

func (e ErrIncorrectEnum) Error() string {
	return fmt.Sprintf("incorrect enum value: %s", e.Value)
}


type ChatType int

const (
	_ ChatType = iota
	ChatTypePrivate
	ChatTypeGroup
	ChatTypeSupergroup
	ChatTypeChannel
)




var valueChatType = map[ChatType]string {
	1 : "private",
	2 : "group",
	3 : "supergroup",
	4 : "channel",
}

var indexChatType = map[string]ChatType {
	"private" : 1,
	"group" : 2,
	"supergroup" : 3,
	"channel" : 4,
}

func (enum ChatType) String() string {
	return valueChatType[enum]
}

func (enum ChatType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *ChatType) UnmarshalText(src []byte) error {
	value, ok := indexChatType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
type EncryptedType int

const (
	_ EncryptedType = iota
	EncryptedTypeTemporaryRegistration
	EncryptedTypePersonalDetails
	EncryptedTypeIdentityCard
	EncryptedTypeAddress
	EncryptedTypeBankStatement
	EncryptedTypeRentalAgreement
	EncryptedTypePassportRegistration
	EncryptedTypePhoneNumber
	EncryptedTypeEmail
	EncryptedTypePassport
	EncryptedTypeDriverLicense
	EncryptedTypeInternalPassport
	EncryptedTypeUtilityBill
)




var valueEncryptedType = map[EncryptedType]string {
	1 : "temporary_registration",
	2 : "personal_details",
	3 : "identity_card",
	4 : "address",
	5 : "bank_statement",
	6 : "rental_agreement",
	7 : "passport_registration",
	8 : "phone_number",
	9 : "email",
	10 : "passport",
	11 : "driver_license",
	12 : "internal_passport",
	13 : "utility_bill",
}

var indexEncryptedType = map[string]EncryptedType {
	"temporary_registration" : 1,
	"personal_details" : 2,
	"identity_card" : 3,
	"address" : 4,
	"bank_statement" : 5,
	"rental_agreement" : 6,
	"passport_registration" : 7,
	"phone_number" : 8,
	"email" : 9,
	"passport" : 10,
	"driver_license" : 11,
	"internal_passport" : 12,
	"utility_bill" : 13,
}

func (enum EncryptedType) String() string {
	return valueEncryptedType[enum]
}

func (enum EncryptedType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *EncryptedType) UnmarshalText(src []byte) error {
	value, ok := indexEncryptedType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
type InlineType int

const (
	_ InlineType = iota
	InlineTypeTypeOfTheResultMustBeMpeg4Gif
	InlineTypeTypeOfTheResultMustBeAudio
	InlineTypeTypeOfTheResultMustBeContact
	InlineTypeTypeOfTheResultMustBeLocation
	InlineTypeTypeOfTheResultMustBeVenue
	InlineTypeTypeOfTheResultMustBeDocument
	InlineTypeTypeOfTheResultMustBeVideo
	InlineTypeTypeOfTheResultMustBePhoto
	InlineTypeTypeOfTheResultMustBeSticker
	InlineTypeTypeOfTheResultMustBeGif
	InlineTypeTypeOfTheResultMustBeVoice
	InlineTypeTypeOfTheResultMustBeGame
	InlineTypeTypeOfTheResultMustBeArticle
)




var valueInlineType = map[InlineType]string {
	1 : "type of the result, must be mpeg4_gif",
	2 : "type of the result, must be audio",
	3 : "type of the result, must be contact",
	4 : "type of the result, must be location",
	5 : "type of the result, must be venue",
	6 : "type of the result, must be document",
	7 : "type of the result, must be video",
	8 : "type of the result, must be photo",
	9 : "type of the result, must be sticker",
	10 : "type of the result, must be gif",
	11 : "type of the result, must be voice",
	12 : "type of the result, must be game",
	13 : "type of the result, must be article",
}

var indexInlineType = map[string]InlineType {
	"type of the result, must be mpeg4_gif" : 1,
	"type of the result, must be audio" : 2,
	"type of the result, must be contact" : 3,
	"type of the result, must be location" : 4,
	"type of the result, must be venue" : 5,
	"type of the result, must be document" : 6,
	"type of the result, must be video" : 7,
	"type of the result, must be photo" : 8,
	"type of the result, must be sticker" : 9,
	"type of the result, must be gif" : 10,
	"type of the result, must be voice" : 11,
	"type of the result, must be game" : 12,
	"type of the result, must be article" : 13,
}

func (enum InlineType) String() string {
	return valueInlineType[enum]
}

func (enum InlineType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *InlineType) UnmarshalText(src []byte) error {
	value, ok := indexInlineType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
type InputType int

const (
	_ InputType = iota
	InputTypeTypeOfTheResultMustBeVideo
	InputTypeTypeOfTheResultMustBeAudio
	InputTypeTypeOfTheResultMustBeDocument
	InputTypeTypeOfTheResultMustBePhoto
	InputTypeTypeOfTheResultMustBeAnimation
)




var valueInputType = map[InputType]string {
	1 : "type of the result, must be video",
	2 : "type of the result, must be audio",
	3 : "type of the result, must be document",
	4 : "type of the result, must be photo",
	5 : "type of the result, must be animation",
}

var indexInputType = map[string]InputType {
	"type of the result, must be video" : 1,
	"type of the result, must be audio" : 2,
	"type of the result, must be document" : 3,
	"type of the result, must be photo" : 4,
	"type of the result, must be animation" : 5,
}

func (enum InputType) String() string {
	return valueInputType[enum]
}

func (enum InputType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *InputType) UnmarshalText(src []byte) error {
	value, ok := indexInputType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
type KeyboardType int

const (
	_ KeyboardType = iota
	KeyboardTypeOptionalIfQuizIsPassedTheUserWillBeAllowedToCreateOnlyPollsInTheQuizModeIfRegularIsPassedOnlyRegularPollsWillBeAllowedOtherwiseTheUserWillBeAllowedToCreateAPollOfAnyType
)




var valueKeyboardType = map[KeyboardType]string {
	1 : "optional. if quiz is passed, the user will be allowed to create only polls in the quiz mode. if regular is passed, only regular polls will be allowed. otherwise, the user will be allowed to create a poll of any type",
}

var indexKeyboardType = map[string]KeyboardType {
	"optional. if quiz is passed, the user will be allowed to create only polls in the quiz mode. if regular is passed, only regular polls will be allowed. otherwise, the user will be allowed to create a poll of any type" : 1,
}

func (enum KeyboardType) String() string {
	return valueKeyboardType[enum]
}

func (enum KeyboardType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *KeyboardType) UnmarshalText(src []byte) error {
	value, ok := indexKeyboardType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
type MessageType int

const (
	_ MessageType = iota
	MessageTypeTypeOfTheEntityCanBementionusernamehashtaghashtagcashtagusdbotCommandstartjobsBoturlhttpstelegramOrgemaildoNotReplytelegramOrgphoneNumber12125550123boldboldTextitalicitalicTextunderlineunderlinedTextstrikethroughstrikethroughTextcodemonowidthStringpremonowidthBlocktextLinkforClickableTextUrlstextMentionforUsersWithoutUsernames
)




var valueMessageType = map[MessageType]string {
	1 : "type of the entity. can be "mention" (@username), "hashtag" (#hashtag), "cashtag" ($usd), "bot_command" (/start@jobs_bot), "url" (https://telegram.org), "email" (do-not-reply@telegram.org), "phone_number" (+1-212-555-0123), "bold" (bold text), "italic" (italic text), "underline" (underlined text), "strikethrough" (strikethrough text), "code" (monowidth string), "pre" (monowidth block), "text_link" (for clickable text urls), "text_mention" (for users without usernames)",
}

var indexMessageType = map[string]MessageType {
	"type of the entity. can be "mention" (@username), "hashtag" (#hashtag), "cashtag" ($usd), "bot_command" (/start@jobs_bot), "url" (https://telegram.org), "email" (do-not-reply@telegram.org), "phone_number" (+1-212-555-0123), "bold" (bold text), "italic" (italic text), "underline" (underlined text), "strikethrough" (strikethrough text), "code" (monowidth string), "pre" (monowidth block), "text_link" (for clickable text urls), "text_mention" (for users without usernames)" : 1,
}

func (enum MessageType) String() string {
	return valueMessageType[enum]
}

func (enum MessageType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *MessageType) UnmarshalText(src []byte) error {
	value, ok := indexMessageType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
type PassportType int

const (
	_ PassportType = iota
	PassportTypeIdentityCard
	PassportTypeInternalPassport
	PassportTypeBankStatement
	PassportTypeRentalAgreement
	PassportTypePassportRegistration
	PassportTypePassport
	PassportTypeDriverLicense
	PassportTypeUtilityBill
	PassportTypeTemporaryRegistration
	PassportTypePersonalDetails
	PassportTypeAddress
	PassportTypeTypeOfElementOfTheUsersTelegramPassportWhichHasTheIssue
)




var valuePassportType = map[PassportType]string {
	1 : "identity_card",
	2 : "internal_passport",
	3 : "bank_statement",
	4 : "rental_agreement",
	5 : "passport_registration",
	6 : "passport",
	7 : "driver_license",
	8 : "utility_bill",
	9 : "temporary_registration",
	10 : "personal_details",
	11 : "address",
	12 : "type of element of the user's telegram passport which has the issue",
}

var indexPassportType = map[string]PassportType {
	"identity_card" : 1,
	"internal_passport" : 2,
	"bank_statement" : 3,
	"rental_agreement" : 4,
	"passport_registration" : 5,
	"passport" : 6,
	"driver_license" : 7,
	"utility_bill" : 8,
	"temporary_registration" : 9,
	"personal_details" : 10,
	"address" : 11,
	"type of element of the user's telegram passport which has the issue" : 12,
}

func (enum PassportType) String() string {
	return valuePassportType[enum]
}

func (enum PassportType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *PassportType) UnmarshalText(src []byte) error {
	value, ok := indexPassportType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
type PollType int

const (
	_ PollType = iota
	PollTypePollTypeCurrentlyCanBeregularOrquiz
)




var valuePollType = map[PollType]string {
	1 : "poll type, currently can be "regular" or "quiz"",
}

var indexPollType = map[string]PollType {
	"poll type, currently can be "regular" or "quiz"" : 1,
}

func (enum PollType) String() string {
	return valuePollType[enum]
}

func (enum PollType) MarshalText() ([]byte, error) {
	return []byte(enum.String()), nil
}

func (enum *PollType) UnmarshalText(src []byte) error {
	value, ok := indexPollType[string(src)]
	if !ok {
		return ErrIncorrectEnum{string(src)}
	}
	*enum = value
	return nil
}
