// Generated by: github.com/Feresey/gen-tgbotapi

package tgapi

import "encoding/json"

// AddStickerToSet
// Use this method to add a new sticker to a set created by the bot. You must use exactly one of
// the fields png_sticker or tgs_sticker. Animated stickers can be added to animated sticker sets
// and only to them. Animated sticker sets can have up to 50 stickers. Static sticker sets can have
// up to 120 stickers. Returns True on success.
type AddStickerToSet struct {
	// Emojis
	// One or more emoji corresponding to the sticker
	Emojis string `json:"emojis"`
	// Name
	// Sticker set name
	Name string `json:"name"`
	// UserID
	// User identifier of sticker set owner
	UserID int64 `json:"user_id"`
	// MaskPosition
	// A JSON-serialized object for position where the mask should be placed on faces
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// PngSticker
	// PNG image with the sticker, must be up to 512 kilobytes in size, dimensions must not exceed
	// 512px, and either width or height must be exactly 512px. Pass a file_id as a String to send
	// a file that already exists on the Telegram servers, pass an HTTP URL as a String for
	// Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
	PngSticker InputDataType `json:"png_sticker,omitempty"`
	// TgsSticker
	// TGS animation with the sticker, uploaded using multipart/form-data. See
	// https://core.telegram.org/animated_stickers#technical-requirements for technical
	// requirements
	TgsSticker *InputFile `json:"tgs_sticker,omitempty"`
}

// AnswerCallbackQuery
// Use this method to send answers to callback queries sent from inline keyboards. The answer will
// be displayed to the user as a notification at the top of the chat screen or as an alert. On
// success, True is returned.
type AnswerCallbackQuery struct {
	// CallbackQueryID
	// Unique identifier for the query to be answered
	CallbackQueryID string `json:"callback_query_id"`
	// CacheTime
	// The maximum amount of time in seconds that the result of the callback query may be cached
	// client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0.
	CacheTime int64 `json:"cache_time,omitempty"`
	// ShowAlert
	// If true, an alert will be shown by the client instead of a notification at the top of the
	// chat screen. Defaults to false.
	ShowAlert bool `json:"show_alert,omitempty"`
	// Text
	// Text of the notification. If not specified, nothing will be shown to the user, 0-200
	// characters
	Text string `json:"text,omitempty"`
	// URL
	// URL that will be opened by the user's client. If you have created a Game and accepted the
	// conditions via @Botfather, specify the URL that opens your game - note that this will only
	// work if the query comes from a callback_game button.Otherwise, you may use links like
	// t.me/your_bot?start=XXXX that open your bot with a parameter.
	URL string `json:"url,omitempty"`
}

// AnswerInlineQuery
// Use this method to send answers to an inline query. On success, True is returned.No more than 50
// results per query are allowed.
type AnswerInlineQuery struct {
	// InlineQueryID
	// Unique identifier for the answered query
	InlineQueryID string `json:"inline_query_id"`
	// Results
	// A JSON-serialized array of results for the inline query
	Results []InlineQueryResult `json:"results"`
	// CacheTime
	// The maximum amount of time in seconds that the result of the inline query may be cached on
	// the server. Defaults to 300.
	CacheTime int64 `json:"cache_time,omitempty"`
	// IsPersonal
	// Pass True, if results may be cached on the server side only for the user that sent the
	// query. By default, results may be returned to any user who sends the same query
	IsPersonal bool `json:"is_personal,omitempty"`
	// NextOffset
	// Pass the offset that a client should send in the next query with the same text to receive
	// more results. Pass an empty string if there are no more results or if you don't support
	// pagination. Offset length can't exceed 64 bytes.
	NextOffset string `json:"next_offset,omitempty"`
	// SwitchPmParameter
	// Deep-linking parameter for the /start message sent to the bot when user presses the switch
	// button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot
	// that sends YouTube videos can ask the user to connect the bot to their YouTube account to
	// adapt search results accordingly. To do this, it displays a 'Connect your YouTube account'
	// button above the results, or even before showing any. The user presses the button, switches
	// to a private chat with the bot and, in doing so, passes a start parameter that instructs the
	// bot to return an oauth link. Once done, the bot can offer a switch_inline button so that the
	// user can easily return to the chat where they wanted to use the bot's inline capabilities.
	SwitchPmParameter string `json:"switch_pm_parameter,omitempty"`
	// SwitchPmText
	// If passed, clients will display a button with specified text that switches the user to a
	// private chat with the bot and sends the bot a start message with the parameter
	// switch_pm_parameter
	SwitchPmText string `json:"switch_pm_text,omitempty"`
}

// AnswerPreCheckoutQuery
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an Update with the field pre_checkout_query. Use this method to
// respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must
// receive an answer within 10 seconds after the pre-checkout query was sent.
type AnswerPreCheckoutQuery struct {
	// Ok
	// Specify True if everything is alright (goods are available, etc.) and the bot is ready to
	// proceed with the order. Use False if there are any problems.
	Ok bool `json:"ok"`
	// PreCheckoutQueryID
	// Unique identifier for the query to be answered
	PreCheckoutQueryID string `json:"pre_checkout_query_id"`
	// ErrorMessage
	// Required if ok is False. Error message in human readable form that explains the reason for
	// failure to proceed with the checkout (e.g. "Sorry, somebody just bought the last of our
	// amazing black T-shirts while you were busy filling out your payment details. Please choose a
	// different color or garment!"). Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
}

// AnswerShippingQuery
// If you sent an invoice requesting a shipping address and the parameter is_flexible was
// specified, the Bot API will send an Update with a shipping_query field to the bot. Use this
// method to reply to shipping queries. On success, True is returned.
type AnswerShippingQuery struct {
	// Ok
	// Specify True if delivery to the specified address is possible and False if there are any
	// problems (for example, if delivery to the specified address is not possible)
	Ok bool `json:"ok"`
	// ShippingQueryID
	// Unique identifier for the query to be answered
	ShippingQueryID string `json:"shipping_query_id"`
	// ErrorMessage
	// Required if ok is False. Error message in human readable form that explains why it is
	// impossible to complete the order (e.g. "Sorry, delivery to your desired address is
	// unavailable'). Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
	// ShippingOptions
	// Required if ok is True. A JSON-serialized array of available shipping options.
	ShippingOptions []ShippingOption `json:"shipping_options,omitempty"`
}

// CreateNewStickerSet
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. You must use exactly one of the fields png_sticker or tgs_sticker.
// Returns True on success.
type CreateNewStickerSet struct {
	// Emojis
	// One or more emoji corresponding to the sticker
	Emojis string `json:"emojis"`
	// Name
	// Short name of sticker set, to be used in t.me/addstickers/ URLs (e.g., animals). Can contain
	// only english letters, digits and underscores. Must begin with a letter, can't contain
	// consecutive underscores and must end in "_by_<bot username>". <bot_username> is case
	// insensitive. 1-64 characters.
	Name string `json:"name"`
	// Title
	// Sticker set title, 1-64 characters
	Title string `json:"title"`
	// UserID
	// User identifier of created sticker set owner
	UserID int64 `json:"user_id"`
	// ContainsMasks
	// Pass True, if a set of mask stickers should be created
	ContainsMasks bool `json:"contains_masks,omitempty"`
	// MaskPosition
	// A JSON-serialized object for position where the mask should be placed on faces
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
	// PngSticker
	// PNG image with the sticker, must be up to 512 kilobytes in size, dimensions must not exceed
	// 512px, and either width or height must be exactly 512px. Pass a file_id as a String to send
	// a file that already exists on the Telegram servers, pass an HTTP URL as a String for
	// Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
	PngSticker InputDataType `json:"png_sticker,omitempty"`
	// TgsSticker
	// TGS animation with the sticker, uploaded using multipart/form-data. See
	// https://core.telegram.org/animated_stickers#technical-requirements for technical
	// requirements
	TgsSticker *InputFile `json:"tgs_sticker,omitempty"`
}

// EditMessageCaption
// Use this method to edit captions of messages. On success, if edited message is sent by the bot,
// the edited Message is returned, otherwise True is returned.
type EditMessageCaption struct {
	// Caption
	// New caption of the message, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageLiveLocation
// Use this method to edit live location messages. A location can be edited until its live_period
// expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if
// the edited message was sent by the bot, the edited Message is returned, otherwise True is
// returned.
type EditMessageLiveLocation struct {
	// Latitude
	// Latitude of new location
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of new location
	Longitude float64 `json:"longitude"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageMedia
// Use this method to edit animation, audio, document, photo, or video messages. If a message is a
// part of a message album, then it can be edited only to a photo or a video. Otherwise, message
// type can be changed arbitrarily. When inline message is edited, new file can't be uploaded. Use
// previously uploaded file via its file_id or specify a URL. On success, if the edited message was
// sent by the bot, the edited Message is returned, otherwise True is returned.
type EditMessageMedia struct {
	// Media
	// A JSON-serialized object for a new media content of the message
	Media InputMedia `json:"media"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageReplyMarkup
// Use this method to edit only the reply markup of messages. On success, if edited message is sent
// by the bot, the edited Message is returned, otherwise True is returned.
type EditMessageReplyMarkup struct {
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageText
// Use this method to edit text and game messages. On success, if edited message is sent by the
// bot, the edited Message is returned, otherwise True is returned.
type EditMessageText struct {
	// Text
	// New text of the message, 1-4096 characters after entities parsing
	Text string `json:"text"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// DisableWebPagePreview
	// Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// ForwardMessage
// Use this method to forward messages of any kind. On success, the sent Message is returned.
type ForwardMessage struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FromChatID
	// Unique identifier for the chat where the original message was sent (or channel username in
	// the format @channelusername)
	FromChatID IntStr `json:"from_chat_id"`
	// MessageID
	// Message identifier in the chat specified in from_chat_id
	MessageID int64 `json:"message_id"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
}

// GetGameHighScores
// Use this method to get data for high score tables. Will return the score of the specified user
// and several of their neighbors in a game. On success, returns an Array of GameHighScore objects.
type GetGameHighScores struct {
	// UserID
	// Target user id
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`
}

// GetUpdates
// Use this method to receive incoming updates using long polling (wiki). An Array of Update
// objects is returned.
type GetUpdates struct {
	// AllowedUpdates
	// A JSON-serialized list of the update types you want your bot to receive. For example,
	// specify ["message", "edited_channel_post", "callback_query"] to only receive updates of
	// these types. See Update for a complete list of available update types. Specify an empty list
	// to receive all updates regardless of type (default). If not specified, the previous setting
	// will be used.Please note that this parameter doesn't affect updates created before the call
	// to the getUpdates, so unwanted updates may be received for a short period of time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// Limit
	// Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to
	// 100.
	Limit int64 `json:"limit,omitempty"`
	// Offset
	// Identifier of the first update to be returned. Must be greater by one than the highest among
	// the identifiers of previously received updates. By default, updates starting with the
	// earliest unconfirmed update are returned. An update is considered confirmed as soon as
	// getUpdates is called with an offset higher than its update_id. The negative offset can be
	// specified to retrieve updates starting from -offset update from the end of the updates
	// queue. All previous updates will forgotten.
	Offset int64 `json:"offset,omitempty"`
	// Timeout
	// Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be
	// positive, short polling should be used for testing purposes only.
	Timeout int64 `json:"timeout,omitempty"`
}

// GetUserProfilePhotos
// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos
// object.
type GetUserProfilePhotos struct {
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// Limit
	// Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to
	// 100.
	Limit int64 `json:"limit,omitempty"`
	// Offset
	// Sequential number of the first photo to be returned. By default, all photos are returned.
	Offset int64 `json:"offset,omitempty"`
}

// KickChatMember
// Use this method to kick a user from a group, a supergroup or a channel. In the case of
// supergroups and channels, the user will not be able to return to the group on their own using
// invite links, etc., unless unbanned first. The bot must be an administrator in the chat for this
// to work and must have the appropriate admin rights. Returns True on success.
type KickChatMember struct {
	// ChatID
	// Unique identifier for the target group or username of the target supergroup or channel (in
	// the format @channelusername)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// UntilDate
	// Date when the user will be unbanned, unix time. If user is banned for more than 366 days or
	// less than 30 seconds from the current time they are considered to be banned forever
	UntilDate int64 `json:"until_date,omitempty"`
}

// PinChatMessage
// Use this method to pin a message in a group, a supergroup, or a channel. The bot must be an
// administrator in the chat for this to work and must have the 'can_pin_messages' admin right in
// the supergroup or 'can_edit_messages' admin right in the channel. Returns True on success.
type PinChatMessage struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// MessageID
	// Identifier of a message to pin
	MessageID int64 `json:"message_id"`
	// DisableNotification
	// Pass True, if it is not necessary to send a notification to all chat members about the new
	// pinned message. Notifications are always disabled in channels.
	DisableNotification bool `json:"disable_notification,omitempty"`
}

// PromoteChatMember
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Pass
// False for all boolean parameters to demote a user. Returns True on success.
type PromoteChatMember struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// CanChangeInfo
	// Pass True, if the administrator can change chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info,omitempty"`
	// CanDeleteMessages
	// Pass True, if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages,omitempty"`
	// CanEditMessages
	// Pass True, if the administrator can edit messages of other users and can pin messages,
	// channels only
	CanEditMessages bool `json:"can_edit_messages,omitempty"`
	// CanInviteUsers
	// Pass True, if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users,omitempty"`
	// CanPinMessages
	// Pass True, if the administrator can pin messages, supergroups only
	CanPinMessages bool `json:"can_pin_messages,omitempty"`
	// CanPostMessages
	// Pass True, if the administrator can create channel posts, channels only
	CanPostMessages bool `json:"can_post_messages,omitempty"`
	// CanPromoteMembers
	// Pass True, if the administrator can add new administrators with a subset of their own
	// privileges or demote administrators that he has promoted, directly or indirectly (promoted
	// by administrators that were appointed by him)
	CanPromoteMembers bool `json:"can_promote_members,omitempty"`
	// CanRestrictMembers
	// Pass True, if the administrator can restrict, ban or unban chat members
	CanRestrictMembers bool `json:"can_restrict_members,omitempty"`
}

// RestrictChatMember
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate admin rights. Pass True for all
// permissions to lift restrictions from a user. Returns True on success.
type RestrictChatMember struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// Permissions
	// A JSON-serialized object for new user permissions
	Permissions ChatPermissions `json:"permissions"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
	// UntilDate
	// Date when restrictions will be lifted for the user, unix time. If user is restricted for
	// more than 366 days or less than 30 seconds from the current time, they are considered to be
	// restricted forever
	UntilDate int64 `json:"until_date,omitempty"`
}

// SendAnimation
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On
// success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in
// size, this limit may be changed in the future.
type SendAnimation struct {
	// Animation
	// Animation to send. Pass a file_id as String to send an animation that exists on the Telegram
	// servers (recommended), pass an HTTP URL as a String for Telegram to get an animation from
	// the Internet, or upload a new animation using multipart/form-data.
	Animation InputDataType `json:"animation"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Caption
	// Animation caption (may also be used when resending animation by file_id), 0-1024 characters
	// after entities parsing
	Caption string `json:"caption,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent animation in seconds
	Duration int64 `json:"duration,omitempty"`
	// Height
	// Animation height
	Height int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the animation caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb InputDataType `json:"thumb,omitempty"`
	// Width
	// Animation width
	Width int64 `json:"width,omitempty"`
}

// SendAudio
// Use this method to send audio files, if you want Telegram clients to display them in the music
// player. Your audio must be in the .MP3 or .M4A format. On success, the sent Message is returned.
// Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the
// future.
type SendAudio struct {
	// Audio
	// Audio file to send. Pass a file_id as String to send an audio file that exists on the
	// Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an audio
	// file from the Internet, or upload a new one using multipart/form-data.
	Audio InputDataType `json:"audio"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Caption
	// Audio caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of the audio in seconds
	Duration int64 `json:"duration,omitempty"`
	// ParseMode
	// Mode for parsing entities in the audio caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// Performer
	// Performer
	Performer string `json:"performer,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb InputDataType `json:"thumb,omitempty"`
	// Title
	// Track name
	Title string `json:"title,omitempty"`
}

// SendContact
// Use this method to send phone contacts. On success, the sent Message is returned.
type SendContact struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// FirstName
	// Contact's first name
	FirstName string `json:"first_name"`
	// PhoneNumber
	// Contact's phone number
	PhoneNumber string `json:"phone_number"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// LastName
	// Contact's last name
	LastName string `json:"last_name,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Vcard
	// Additional data about the contact in the form of a vCard, 0-2048 bytes
	Vcard string `json:"vcard,omitempty"`
}

// SendDice
// Use this method to send an animated emoji that will display a random value. On success, the sent
// Message is returned.
type SendDice struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Emoji
	// Emoji on which the dice throw animation is based. Currently, must be one of "", "", or "".
	// Dice can have values 1-6 for "" and "", and values 1-5 for "". Defaults to ""
	Emoji string `json:"emoji,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendDocument
// Use this method to send general files. On success, the sent Message is returned. Bots can
// currently send files of any type of up to 50 MB in size, this limit may be changed in the
// future.
type SendDocument struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Document
	// File to send. Pass a file_id as String to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or
	// upload a new one using multipart/form-data.
	Document InputDataType `json:"document"`
	// Caption
	// Document caption (may also be used when resending documents by file_id), 0-1024 characters
	// after entities parsing
	Caption string `json:"caption,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ParseMode
	// Mode for parsing entities in the document caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb InputDataType `json:"thumb,omitempty"`
}

// SendGame
// Use this method to send a game. On success, the sent Message is returned.
type SendGame struct {
	// ChatID
	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id"`
	// GameShortName
	// Short name of the game, serves as the unique identifier for the game. Set up your games via
	// Botfather.
	GameShortName string `json:"game_short_name"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Play game_title' button will
	// be shown. If not empty, the first button must launch the game.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendInvoice
// Use this method to send invoices. On success, the sent Message is returned.
type SendInvoice struct {
	// ChatID
	// Unique identifier for the target private chat
	ChatID int64 `json:"chat_id"`
	// Currency
	// Three-letter ISO 4217 currency code, see more on currencies
	Currency string `json:"currency"`
	// Description
	// Product description, 1-255 characters
	Description string `json:"description"`
	// Payload
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for
	// your internal processes.
	Payload string `json:"payload"`
	// Prices
	// Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount,
	// delivery cost, delivery tax, bonus, etc.)
	Prices []LabeledPrice `json:"prices"`
	// ProviderToken
	// Payments provider token, obtained via Botfather
	ProviderToken string `json:"provider_token"`
	// StartParameter
	// Unique deep-linking parameter that can be used to generate this invoice when used as a start
	// parameter
	StartParameter string `json:"start_parameter"`
	// Title
	// Product name, 1-32 characters
	Title string `json:"title"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// IsFlexible
	// Pass True, if the final price depends on the shipping method
	IsFlexible bool `json:"is_flexible,omitempty"`
	// NeedEmail
	// Pass True, if you require the user's email address to complete the order
	NeedEmail bool `json:"need_email,omitempty"`
	// NeedName
	// Pass True, if you require the user's full name to complete the order
	NeedName bool `json:"need_name,omitempty"`
	// NeedPhoneNumber
	// Pass True, if you require the user's phone number to complete the order
	NeedPhoneNumber bool `json:"need_phone_number,omitempty"`
	// NeedShippingAddress
	// Pass True, if you require the user's shipping address to complete the order
	NeedShippingAddress bool `json:"need_shipping_address,omitempty"`
	// PhotoHeight
	// Photo height
	PhotoHeight int64 `json:"photo_height,omitempty"`
	// PhotoSize
	// Photo size
	PhotoSize int64 `json:"photo_size,omitempty"`
	// PhotoURL
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image
	// for a service. People like it better when they see what they are paying for.
	PhotoURL string `json:"photo_url,omitempty"`
	// PhotoWidth
	// Photo width
	PhotoWidth int64 `json:"photo_width,omitempty"`
	// ProviderData
	// A JSON-serialized data about the invoice, which will be shared with the payment provider. A
	// detailed description of required fields should be provided by the payment provider.
	ProviderData string `json:"provider_data,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will
	// be shown. If not empty, the first button must be a Pay button.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// SendEmailToProvider
	// Pass True, if user's email address should be sent to provider
	SendEmailToProvider bool `json:"send_email_to_provider,omitempty"`
	// SendPhoneNumberToProvider
	// Pass True, if user's phone number should be sent to provider
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider,omitempty"`
}

// SendLocation
// Use this method to send point on the map. On success, the sent Message is returned.
type SendLocation struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Latitude
	// Latitude of the location
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the location
	Longitude float64 `json:"longitude"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// LivePeriod
	// Period in seconds for which the location will be updated (see Live Locations, should be
	// between 60 and 86400.
	LivePeriod int64 `json:"live_period,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendMediaGroup
// Use this method to send a group of photos or videos as an album. On success, an array of the
// sent Messages is returned.
type SendMediaGroup struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Media
	// A JSON-serialized array describing photos and videos to be sent, must include 2-10 items
	Media []InputMediaGraphics `json:"media"`
	// DisableNotification
	// Sends the messages silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ReplyToMessageID
	// If the messages are a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendMessage
// Use this method to send text messages. On success, the sent Message is returned.
type SendMessage struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Text
	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// DisableWebPagePreview
	// Disables link previews for links in this message
	DisableWebPagePreview bool `json:"disable_web_page_preview,omitempty"`
	// ParseMode
	// Mode for parsing entities in the message text. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendPhoto
// Use this method to send photos. On success, the sent Message is returned.
type SendPhoto struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Photo
	// Photo to send. Pass a file_id as String to send a photo that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a photo from the Internet,
	// or upload a new photo using multipart/form-data.
	Photo InputDataType `json:"photo"`
	// Caption
	// Photo caption (may also be used when resending photos by file_id), 0-1024 characters after
	// entities parsing
	Caption string `json:"caption,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ParseMode
	// Mode for parsing entities in the photo caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendPoll
// Use this method to send a native poll. On success, the sent Message is returned.
type SendPoll struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Options
	// A JSON-serialized list of answer options, 2-10 strings 1-100 characters each
	Options []string `json:"options"`
	// Question
	// Poll question, 1-255 characters
	Question string `json:"question"`
	// AllowsMultipleAnswers
	// True, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to False
	AllowsMultipleAnswers bool `json:"allows_multiple_answers,omitempty"`
	// CloseDate
	// Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least
	// 5 and no more than 600 seconds in the future. Can't be used together with open_period.
	CloseDate int64 `json:"close_date,omitempty"`
	// CorrectOptionID
	// 0-based identifier of the correct answer option, required for polls in quiz mode
	CorrectOptionID int64 `json:"correct_option_id,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Explanation
	// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a
	// quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
	Explanation string `json:"explanation,omitempty"`
	// ExplanationParseMode
	// Mode for parsing entities in the explanation. See formatting options for more details.
	ExplanationParseMode string `json:"explanation_parse_mode,omitempty"`
	// IsAnonymous
	// True, if the poll needs to be anonymous, defaults to True
	IsAnonymous bool `json:"is_anonymous,omitempty"`
	// IsClosed
	// Pass True, if the poll needs to be immediately closed. This can be useful for poll preview.
	IsClosed bool `json:"is_closed,omitempty"`
	// OpenPeriod
	// Amount of time in seconds the poll will be active after creation, 5-600. Can't be used
	// together with close_date.
	OpenPeriod int64 `json:"open_period,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Type
	// Poll type, "quiz" or "regular", defaults to "regular"
	Type *SendType `json:"type,omitempty"`
}

// SendSticker
// Use this method to send static .WEBP or animated .TGS stickers. On success, the sent Message is
// returned.
type SendSticker struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Sticker
	// Sticker to send. Pass a file_id as String to send a file that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a .WEBP file from the
	// Internet, or upload a new one using multipart/form-data.
	Sticker InputDataType `json:"sticker"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendVenue
// Use this method to send information about a venue. On success, the sent Message is returned.
type SendVenue struct {
	// Address
	// Address of the venue
	Address string `json:"address"`
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Latitude
	// Latitude of the venue
	Latitude float64 `json:"latitude"`
	// Longitude
	// Longitude of the venue
	Longitude float64 `json:"longitude"`
	// Title
	// Name of the venue
	Title string `json:"title"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// FoursquareID
	// Foursquare identifier of the venue
	FoursquareID string `json:"foursquare_id,omitempty"`
	// FoursquareType
	// Foursquare type of the venue, if known. (For example, "arts_entertainment/default",
	// "arts_entertainment/aquarium" or "food/icecream".)
	FoursquareType string `json:"foursquare_type,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SendVideo
// Use this method to send video files, Telegram clients support mp4 videos (other formats may be
// sent as Document). On success, the sent Message is returned. Bots can currently send video files
// of up to 50 MB in size, this limit may be changed in the future.
type SendVideo struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Video
	// Video to send. Pass a file_id as String to send a video that exists on the Telegram servers
	// (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet,
	// or upload a new video using multipart/form-data.
	Video InputDataType `json:"video"`
	// Caption
	// Video caption (may also be used when resending videos by file_id), 0-1024 characters after
	// entities parsing
	Caption string `json:"caption,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`
	// Height
	// Video height
	Height int64 `json:"height,omitempty"`
	// ParseMode
	// Mode for parsing entities in the video caption. See formatting options for more details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// SupportsStreaming
	// Pass True, if the uploaded video is suitable for streaming
	SupportsStreaming bool `json:"supports_streaming,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb InputDataType `json:"thumb,omitempty"`
	// Width
	// Video width
	Width int64 `json:"width,omitempty"`
}

// SendVideoNote
// As of v.4.0, Telegram clients support rounded square mp4 videos of up to 1 minute long. Use this
// method to send video messages. On success, the sent Message is returned.
type SendVideoNote struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// VideoNote
	// Video note to send. Pass a file_id as String to send a video note that exists on the
	// Telegram servers (recommended) or upload a new video using multipart/form-data. . Sending
	// video notes by a URL is currently unsupported
	VideoNote InputDataType `json:"video_note"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`
	// Length
	// Video width and height, i.e. diameter of the video message
	Length int64 `json:"length,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
	// Thumb
	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported
	// server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A
	// thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded
	// using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new
	// file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using
	// multipart/form-data under <file_attach_name>.
	Thumb InputDataType `json:"thumb,omitempty"`
}

// SendVoice
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS
// (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots
// can currently send voice messages of up to 50 MB in size, this limit may be changed in the
// future.
type SendVoice struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// Voice
	// Audio file to send. Pass a file_id as String to send a file that exists on the Telegram
	// servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the
	// Internet, or upload a new one using multipart/form-data.
	Voice InputDataType `json:"voice"`
	// Caption
	// Voice message caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`
	// DisableNotification
	// Sends the message silently. Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`
	// Duration
	// Duration of the voice message in seconds
	Duration int64 `json:"duration,omitempty"`
	// ParseMode
	// Mode for parsing entities in the voice message caption. See formatting options for more
	// details.
	ParseMode string `json:"parse_mode,omitempty"`
	// ReplyMarkup
	// Additional interface options. A JSON-serialized object for an inline keyboard, custom reply
	// keyboard, instructions to remove reply keyboard or to force a reply from the user.
	ReplyMarkup ReplyMarkup `json:"reply_markup,omitempty"`
	// ReplyToMessageID
	// If the message is a reply, ID of the original message
	ReplyToMessageID int64 `json:"reply_to_message_id,omitempty"`
}

// SetChatAdministratorCustomTitle
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns True on success.
type SetChatAdministratorCustomTitle struct {
	// ChatID
	// Unique identifier for the target chat or username of the target supergroup (in the format
	// @supergroupusername)
	ChatID IntStr `json:"chat_id"`
	// CustomTitle
	// New custom title for the administrator; 0-16 characters, emoji are not allowed
	CustomTitle string `json:"custom_title"`
	// UserID
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// SetGameScore
// Use this method to set the score of the specified user in a game. On success, if the message was
// sent by the bot, returns the edited Message, otherwise returns True. Returns an error, if the
// new score is not greater than the user's current score in the chat and force is False.
type SetGameScore struct {
	// Score
	// New score, must be non-negative
	Score int64 `json:"score"`
	// UserID
	// User identifier
	UserID int64 `json:"user_id"`
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`
	// DisableEditMessage
	// Pass True, if the game message should not be automatically edited to include the current
	// scoreboard
	DisableEditMessage bool `json:"disable_edit_message,omitempty"`
	// Force
	// Pass True, if the high score is allowed to decrease. This can be useful when fixing mistakes
	// or banning cheaters
	Force bool `json:"force,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`
}

// SetStickerSetThumb
// Use this method to set the thumbnail of a sticker set. Animated thumbnails can be set for
// animated sticker sets only. Returns True on success.
type SetStickerSetThumb struct {
	// Name
	// Sticker set name
	Name string `json:"name"`
	// UserID
	// User identifier of the sticker set owner
	UserID int64 `json:"user_id"`
	// Thumb
	// A PNG image with the thumbnail, must be up to 128 kilobytes in size and have width and
	// height exactly 100px, or a TGS animation with the thumbnail up to 32 kilobytes in size; see
	// https://core.telegram.org/animated_stickers#technical-requirements for animated sticker
	// technical requirements. Pass a file_id as a String to send a file that already exists on the
	// Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet,
	// or upload a new one using multipart/form-data. . Animated sticker set thumbnail can't be
	// uploaded via HTTP URL.
	Thumb InputDataType `json:"thumb,omitempty"`
}

// SetWebhook
// Use this method to specify a url and receive incoming updates via an outgoing webhook. Whenever
// there is an update for the bot, we will send an HTTPS POST request to the specified url,
// containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a
// reasonable amount of attempts. Returns True on success.
type SetWebhook struct {
	// URL
	// HTTPS url to send updates to. Use an empty string to remove webhook integration
	URL string `json:"url"`
	// AllowedUpdates
	// A JSON-serialized list of the update types you want your bot to receive. For example,
	// specify ["message", "edited_channel_post", "callback_query"] to only receive updates of
	// these types. See Update for a complete list of available update types. Specify an empty list
	// to receive all updates regardless of type (default). If not specified, the previous setting
	// will be used.Please note that this parameter doesn't affect updates created before the call
	// to the setWebhook, so unwanted updates may be received for a short period of time.
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
	// Certificate
	// Upload your public key certificate so that the root certificate in use can be checked. See
	// our self-signed guide for details.
	Certificate *InputFile `json:"certificate,omitempty"`
	// MaxConnections
	// Maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery,
	// 1-100. Defaults to 40. Use lower values to limit the load on your bot's server, and higher
	// values to increase your bot's throughput.
	MaxConnections int64 `json:"max_connections,omitempty"`
}

// StopMessageLiveLocation
// Use this method to stop updating a live location message before live_period expires. On success,
// if the message was sent by the bot, the sent Message is returned, otherwise True is returned.
type StopMessageLiveLocation struct {
	// ChatID
	// Required if inline_message_id is not specified. Unique identifier for the target chat or
	// username of the target channel (in the format @channelusername)
	ChatID IntStr `json:"chat_id,omitempty"`
	// InlineMessageID
	// Required if chat_id and message_id are not specified. Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
	// MessageID
	// Required if inline_message_id is not specified. Identifier of the message with live location
	// to stop
	MessageID int64 `json:"message_id,omitempty"`
	// ReplyMarkup
	// A JSON-serialized object for a new inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// StopPoll
// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll with the
// final results is returned.
type StopPoll struct {
	// ChatID
	// Unique identifier for the target chat or username of the target channel (in the format
	// @channelusername)
	ChatID IntStr `json:"chat_id"`
	// MessageID
	// Identifier of the original message with the poll
	MessageID int64 `json:"message_id"`
	// ReplyMarkup
	// A JSON-serialized object for a new message inline keyboard.
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// AddStickerToSet
// Use this method to add a new sticker to a set created by the bot. You must use exactly one of
// the fields png_sticker or tgs_sticker. Animated stickers can be added to animated sticker sets
// and only to them. Animated sticker sets can have up to 50 stickers. Static sticker sets can have
// up to 120 stickers. Returns True on success.
func (api *API) AddStickerToSet(args *AddStickerToSet) (*Response, error) {
	return api.MakeRequest("addStickerToSet", args)
}

// AnswerCallbackQuery
// Use this method to send answers to callback queries sent from inline keyboards. The answer will
// be displayed to the user as a notification at the top of the chat screen or as an alert. On
// success, True is returned.
func (api *API) AnswerCallbackQuery(args *AnswerCallbackQuery) (*Response, error) {
	return api.MakeRequest("answerCallbackQuery", args)
}

// AnswerInlineQuery
// Use this method to send answers to an inline query. On success, True is returned.No more than 50
// results per query are allowed.
func (api *API) AnswerInlineQuery(args *AnswerInlineQuery) (*Response, error) {
	return api.MakeRequest("answerInlineQuery", args)
}

// AnswerPreCheckoutQuery
// Once the user has confirmed their payment and shipping details, the Bot API sends the final
// confirmation in the form of an Update with the field pre_checkout_query. Use this method to
// respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must
// receive an answer within 10 seconds after the pre-checkout query was sent.
func (api *API) AnswerPreCheckoutQuery(args *AnswerPreCheckoutQuery) (*Response, error) {
	return api.MakeRequest("answerPreCheckoutQuery", args)
}

// AnswerShippingQuery
// If you sent an invoice requesting a shipping address and the parameter is_flexible was
// specified, the Bot API will send an Update with a shipping_query field to the bot. Use this
// method to reply to shipping queries. On success, True is returned.
func (api *API) AnswerShippingQuery(args *AnswerShippingQuery) (*Response, error) {
	return api.MakeRequest("answerShippingQuery", args)
}

// CreateNewStickerSet
// Use this method to create a new sticker set owned by a user. The bot will be able to edit the
// sticker set thus created. You must use exactly one of the fields png_sticker or tgs_sticker.
// Returns True on success.
func (api *API) CreateNewStickerSet(args *CreateNewStickerSet) (*Response, error) {
	return api.MakeRequest("createNewStickerSet", args)
}

// DeleteChatPhoto
// Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must
// be an administrator in the chat for this to work and must have the appropriate admin rights.
// Returns True on success.
func (api *API) DeleteChatPhoto(chatID IntStr) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
	}
	return api.MakeRequest("deleteChatPhoto", args)
}

// DeleteChatStickerSet
// Use this method to delete a group sticker set from a supergroup. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Use the
// field can_set_sticker_set optionally returned in getChat requests to check if the bot can use
// this method. Returns True on success.
func (api *API) DeleteChatStickerSet(chatID IntStr) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup (in the format
		// @supergroupusername)
		"chat_id": chatID,
	}
	return api.MakeRequest("deleteChatStickerSet", args)
}

// DeleteMessage
// Use this method to delete a message, including service messages, with the following
// limitations:- A message can only be deleted if it was sent less than 48 hours ago.- A dice
// message in a private chat can only be deleted if it was sent more than 24 hours ago.- Bots can
// delete outgoing messages in private chats, groups, and supergroups.- Bots can delete incoming
// messages in private chats.- Bots granted can_post_messages permissions can delete outgoing
// messages in channels.- If the bot is an administrator of a group, it can delete any message
// there.- If the bot has can_delete_messages permission in a supergroup or a channel, it can
// delete any message there.Returns True on success.
func (api *API) DeleteMessage(chatID IntStr, messageID int64) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
		// Identifier of the message to delete
		"message_id": messageID,
	}
	return api.MakeRequest("deleteMessage", args)
}

// DeleteStickerFromSet
// Use this method to delete a sticker from a set created by the bot. Returns True on success.
func (api *API) DeleteStickerFromSet(sticker string) (*Response, error) {
	args := map[string]interface{}{
		// File identifier of the sticker
		"sticker": sticker,
	}
	return api.MakeRequest("deleteStickerFromSet", args)
}

// DeleteWebhook
// Use this method to remove webhook integration if you decide to switch back to getUpdates.
// Returns True on success. Requires no parameters.
func (api *API) DeleteWebhook() (*Response, error) {
	return api.MakeRequest("deleteWebhook", nil)
}

// EditMessageCaption
// Use this method to edit captions of messages. On success, if edited message is sent by the bot,
// the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageCaption(args *EditMessageCaption) (*Message, *Response, error) {
	resp, err := api.MakeRequest("editMessageCaption", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// EditMessageLiveLocation
// Use this method to edit live location messages. A location can be edited until its live_period
// expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if
// the edited message was sent by the bot, the edited Message is returned, otherwise True is
// returned.
func (api *API) EditMessageLiveLocation(args *EditMessageLiveLocation) (*Message, *Response, error) {
	resp, err := api.MakeRequest("editMessageLiveLocation", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// EditMessageMedia
// Use this method to edit animation, audio, document, photo, or video messages. If a message is a
// part of a message album, then it can be edited only to a photo or a video. Otherwise, message
// type can be changed arbitrarily. When inline message is edited, new file can't be uploaded. Use
// previously uploaded file via its file_id or specify a URL. On success, if the edited message was
// sent by the bot, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageMedia(args *EditMessageMedia) (*Message, *Response, error) {
	resp, err := api.MakeRequest("editMessageMedia", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// EditMessageReplyMarkup
// Use this method to edit only the reply markup of messages. On success, if edited message is sent
// by the bot, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageReplyMarkup(args *EditMessageReplyMarkup) (*Message, *Response, error) {
	resp, err := api.MakeRequest("editMessageReplyMarkup", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// EditMessageText
// Use this method to edit text and game messages. On success, if edited message is sent by the
// bot, the edited Message is returned, otherwise True is returned.
func (api *API) EditMessageText(args *EditMessageText) (*Message, *Response, error) {
	resp, err := api.MakeRequest("editMessageText", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// ExportChatInviteLink
// Use this method to generate a new invite link for a chat; any previously generated link is
// revoked. The bot must be an administrator in the chat for this to work and must have the
// appropriate admin rights. Returns the new invite link as String on success.
func (api *API) ExportChatInviteLink(chatID IntStr) (string, *Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest("exportChatInviteLink", args)
	if err != nil {
		return "", resp, err
	}
	var data string
	err = json.Unmarshal(resp.Result, &data)
	return data, resp, err
}

// ForwardMessage
// Use this method to forward messages of any kind. On success, the sent Message is returned.
func (api *API) ForwardMessage(args *ForwardMessage) (*Message, *Response, error) {
	resp, err := api.MakeRequest("forwardMessage", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// GetChat
// Use this method to get up to date information about the chat (current name of the user for
// one-on-one conversations, current username of a user, group or channel, etc.). Returns a Chat
// object on success.
func (api *API) GetChat(chatID IntStr) (*Chat, *Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup or channel (in
		// the format @channelusername)
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest("getChat", args)
	if err != nil {
		return nil, resp, err
	}
	var data Chat
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// GetChatAdministrators
// Use this method to get a list of administrators in a chat. On success, returns an Array of
// ChatMember objects that contains information about all chat administrators except other bots. If
// the chat is a group or a supergroup and no administrators were appointed, only the creator will
// be returned.
func (api *API) GetChatAdministrators(chatID IntStr) ([]ChatMember, *Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup or channel (in
		// the format @channelusername)
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest("getChatAdministrators", args)
	if err != nil {
		return nil, resp, err
	}
	var data []ChatMember
	err = json.Unmarshal(resp.Result, &data)
	return data, resp, err
}

// GetChatMember
// Use this method to get information about a member of a chat. Returns a ChatMember object on
// success.
func (api *API) GetChatMember(chatID IntStr, userID int64) (*ChatMember, *Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup or channel (in
		// the format @channelusername)
		"chat_id": chatID,
		// Unique identifier of the target user
		"user_id": userID,
	}
	resp, err := api.MakeRequest("getChatMember", args)
	if err != nil {
		return nil, resp, err
	}
	var data ChatMember
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// GetChatMembersCount
// Use this method to get the number of members in a chat. Returns Int on success.
func (api *API) GetChatMembersCount(chatID IntStr) (int64, *Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup or channel (in
		// the format @channelusername)
		"chat_id": chatID,
	}
	resp, err := api.MakeRequest("getChatMembersCount", args)
	if err != nil {
		return 0, resp, err
	}
	var data int64
	err = json.Unmarshal(resp.Result, &data)
	return data, resp, err
}

// GetFile
// Use this method to get basic info about a file and prepare it for downloading. For the moment,
// bots can download files of up to 20MB in size. On success, a File object is returned. The file
// can then be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>, where
// <file_path> is taken from the response. It is guaranteed that the link will be valid for at
// least 1 hour. When the link expires, a new one can be requested by calling getFile again.
func (api *API) GetFile(fileID string) (*File, *Response, error) {
	args := map[string]interface{}{
		// File identifier to get info about
		"file_id": fileID,
	}
	resp, err := api.MakeRequest("getFile", args)
	if err != nil {
		return nil, resp, err
	}
	var data File
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// GetGameHighScores
// Use this method to get data for high score tables. Will return the score of the specified user
// and several of their neighbors in a game. On success, returns an Array of GameHighScore objects.
func (api *API) GetGameHighScores(args *GetGameHighScores) ([]GameHighScore, *Response, error) {
	resp, err := api.MakeRequest("getGameHighScores", args)
	if err != nil {
		return nil, resp, err
	}
	var data []GameHighScore
	err = json.Unmarshal(resp.Result, &data)
	return data, resp, err
}

// GetMe
// A simple method for testing your bot's auth token. Requires no parameters. Returns basic
// information about the bot in form of a User object.
func (api *API) GetMe() (*User, *Response, error) {
	resp, err := api.MakeRequest("getMe", nil)
	if err != nil {
		return nil, resp, err
	}
	var data User
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// GetMyCommands
// Use this method to get the current list of the bot's commands. Requires no parameters. Returns
// Array of BotCommand on success.
func (api *API) GetMyCommands() ([]BotCommand, *Response, error) {
	resp, err := api.MakeRequest("getMyCommands", nil)
	if err != nil {
		return nil, resp, err
	}
	var data []BotCommand
	err = json.Unmarshal(resp.Result, &data)
	return data, resp, err
}

// GetStickerSet
// Use this method to get a sticker set. On success, a StickerSet object is returned.
func (api *API) GetStickerSet(name string) (*StickerSet, *Response, error) {
	args := map[string]interface{}{
		// Name of the sticker set
		"name": name,
	}
	resp, err := api.MakeRequest("getStickerSet", args)
	if err != nil {
		return nil, resp, err
	}
	var data StickerSet
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// GetUpdates
// Use this method to receive incoming updates using long polling (wiki). An Array of Update
// objects is returned.
func (api *API) GetUpdates(args *GetUpdates) ([]Update, *Response, error) {
	resp, err := api.MakeRequest("getUpdates", args)
	if err != nil {
		return nil, resp, err
	}
	var data []Update
	err = json.Unmarshal(resp.Result, &data)
	return data, resp, err
}

// GetUserProfilePhotos
// Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos
// object.
func (api *API) GetUserProfilePhotos(args *GetUserProfilePhotos) (*UserProfilePhotos, *Response, error) {
	resp, err := api.MakeRequest("getUserProfilePhotos", args)
	if err != nil {
		return nil, resp, err
	}
	var data UserProfilePhotos
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// GetWebhookInfo
// Use this method to get current webhook status. Requires no parameters. On success, returns a
// WebhookInfo object. If the bot is using getUpdates, will return an object with the url field
// empty.
func (api *API) GetWebhookInfo() (*WebhookInfo, *Response, error) {
	resp, err := api.MakeRequest("getWebhookInfo", nil)
	if err != nil {
		return nil, resp, err
	}
	var data WebhookInfo
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// KickChatMember
// Use this method to kick a user from a group, a supergroup or a channel. In the case of
// supergroups and channels, the user will not be able to return to the group on their own using
// invite links, etc., unless unbanned first. The bot must be an administrator in the chat for this
// to work and must have the appropriate admin rights. Returns True on success.
func (api *API) KickChatMember(args *KickChatMember) (*Response, error) {
	return api.MakeRequest("kickChatMember", args)
}

// LeaveChat
// Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
func (api *API) LeaveChat(chatID IntStr) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup or channel (in
		// the format @channelusername)
		"chat_id": chatID,
	}
	return api.MakeRequest("leaveChat", args)
}

// PinChatMessage
// Use this method to pin a message in a group, a supergroup, or a channel. The bot must be an
// administrator in the chat for this to work and must have the 'can_pin_messages' admin right in
// the supergroup or 'can_edit_messages' admin right in the channel. Returns True on success.
func (api *API) PinChatMessage(args *PinChatMessage) (*Response, error) {
	return api.MakeRequest("pinChatMessage", args)
}

// PromoteChatMember
// Use this method to promote or demote a user in a supergroup or a channel. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Pass
// False for all boolean parameters to demote a user. Returns True on success.
func (api *API) PromoteChatMember(args *PromoteChatMember) (*Response, error) {
	return api.MakeRequest("promoteChatMember", args)
}

// RestrictChatMember
// Use this method to restrict a user in a supergroup. The bot must be an administrator in the
// supergroup for this to work and must have the appropriate admin rights. Pass True for all
// permissions to lift restrictions from a user. Returns True on success.
func (api *API) RestrictChatMember(args *RestrictChatMember) (*Response, error) {
	return api.MakeRequest("restrictChatMember", args)
}

// SendAnimation
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On
// success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in
// size, this limit may be changed in the future.
func (api *API) SendAnimation(args *SendAnimation) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendAnimation", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendAudio
// Use this method to send audio files, if you want Telegram clients to display them in the music
// player. Your audio must be in the .MP3 or .M4A format. On success, the sent Message is returned.
// Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the
// future.
func (api *API) SendAudio(args *SendAudio) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendAudio", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendChatAction
// Use this method when you need to tell the user that something is happening on the bot's side.
// The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients
// clear its typing status). Returns True on success.
func (api *API) SendChatAction(action string, chatID IntStr) (*Response, error) {
	args := map[string]interface{}{
		// Type of action to broadcast. Choose one, depending on what the user is about to receive:
		// typing for text messages, upload_photo for photos, record_video or upload_video for videos,
		// record_audio or upload_audio for audio files, upload_document for general files,
		// find_location for location data, record_video_note or upload_video_note for video notes.
		"action": action,
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
	}
	return api.MakeRequest("sendChatAction", args)
}

// SendContact
// Use this method to send phone contacts. On success, the sent Message is returned.
func (api *API) SendContact(args *SendContact) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendContact", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendDice
// Use this method to send an animated emoji that will display a random value. On success, the sent
// Message is returned.
func (api *API) SendDice(args *SendDice) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendDice", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendDocument
// Use this method to send general files. On success, the sent Message is returned. Bots can
// currently send files of any type of up to 50 MB in size, this limit may be changed in the
// future.
func (api *API) SendDocument(args *SendDocument) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendDocument", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendGame
// Use this method to send a game. On success, the sent Message is returned.
func (api *API) SendGame(args *SendGame) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendGame", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendInvoice
// Use this method to send invoices. On success, the sent Message is returned.
func (api *API) SendInvoice(args *SendInvoice) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendInvoice", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendLocation
// Use this method to send point on the map. On success, the sent Message is returned.
func (api *API) SendLocation(args *SendLocation) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendLocation", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendMediaGroup
// Use this method to send a group of photos or videos as an album. On success, an array of the
// sent Messages is returned.
func (api *API) SendMediaGroup(args *SendMediaGroup) ([]Message, *Response, error) {
	resp, err := api.MakeRequest("sendMediaGroup", args)
	if err != nil {
		return nil, resp, err
	}
	var data []Message
	err = json.Unmarshal(resp.Result, &data)
	return data, resp, err
}

// SendMessage
// Use this method to send text messages. On success, the sent Message is returned.
func (api *API) SendMessage(args *SendMessage) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendMessage", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendPhoto
// Use this method to send photos. On success, the sent Message is returned.
func (api *API) SendPhoto(args *SendPhoto) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendPhoto", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendPoll
// Use this method to send a native poll. On success, the sent Message is returned.
func (api *API) SendPoll(args *SendPoll) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendPoll", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendSticker
// Use this method to send static .WEBP or animated .TGS stickers. On success, the sent Message is
// returned.
func (api *API) SendSticker(args *SendSticker) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendSticker", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendVenue
// Use this method to send information about a venue. On success, the sent Message is returned.
func (api *API) SendVenue(args *SendVenue) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendVenue", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendVideo
// Use this method to send video files, Telegram clients support mp4 videos (other formats may be
// sent as Document). On success, the sent Message is returned. Bots can currently send video files
// of up to 50 MB in size, this limit may be changed in the future.
func (api *API) SendVideo(args *SendVideo) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendVideo", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendVideoNote
// As of v.4.0, Telegram clients support rounded square mp4 videos of up to 1 minute long. Use this
// method to send video messages. On success, the sent Message is returned.
func (api *API) SendVideoNote(args *SendVideoNote) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendVideoNote", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SendVoice
// Use this method to send audio files, if you want Telegram clients to display the file as a
// playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS
// (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots
// can currently send voice messages of up to 50 MB in size, this limit may be changed in the
// future.
func (api *API) SendVoice(args *SendVoice) (*Message, *Response, error) {
	resp, err := api.MakeRequest("sendVoice", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SetChatAdministratorCustomTitle
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns True on success.
func (api *API) SetChatAdministratorCustomTitle(args *SetChatAdministratorCustomTitle) (*Response, error) {
	return api.MakeRequest("setChatAdministratorCustomTitle", args)
}

// SetChatDescription
// Use this method to change the description of a group, a supergroup or a channel. The bot must be
// an administrator in the chat for this to work and must have the appropriate admin rights.
// Returns True on success.
func (api *API) SetChatDescription(chatID IntStr, description string) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
		// New chat description, 0-255 characters
		"description": description,
	}
	return api.MakeRequest("setChatDescription", args)
}

// SetChatPermissions
// Use this method to set default chat permissions for all members. The bot must be an
// administrator in the group or a supergroup for this to work and must have the
// can_restrict_members admin rights. Returns True on success.
func (api *API) SetChatPermissions(chatID IntStr, permissions ChatPermissions) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup (in the format
		// @supergroupusername)
		"chat_id": chatID,
		// New default chat permissions
		"permissions": permissions,
	}
	return api.MakeRequest("setChatPermissions", args)
}

// SetChatPhoto
// Use this method to set a new profile photo for the chat. Photos can't be changed for private
// chats. The bot must be an administrator in the chat for this to work and must have the
// appropriate admin rights. Returns True on success.
func (api *API) SetChatPhoto(chatID IntStr, photo InputFile) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
		// New chat photo, uploaded using multipart/form-data
		"photo": photo,
	}
	return api.MakeRequest("setChatPhoto", args)
}

// SetChatStickerSet
// Use this method to set a new group sticker set for a supergroup. The bot must be an
// administrator in the chat for this to work and must have the appropriate admin rights. Use the
// field can_set_sticker_set optionally returned in getChat requests to check if the bot can use
// this method. Returns True on success.
func (api *API) SetChatStickerSet(chatID IntStr, stickerSetName string) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target supergroup (in the format
		// @supergroupusername)
		"chat_id": chatID,
		// Name of the sticker set to be set as the group sticker set
		"sticker_set_name": stickerSetName,
	}
	return api.MakeRequest("setChatStickerSet", args)
}

// SetChatTitle
// Use this method to change the title of a chat. Titles can't be changed for private chats. The
// bot must be an administrator in the chat for this to work and must have the appropriate admin
// rights. Returns True on success.
func (api *API) SetChatTitle(chatID IntStr, title string) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
		// New chat title, 1-255 characters
		"title": title,
	}
	return api.MakeRequest("setChatTitle", args)
}

// SetGameScore
// Use this method to set the score of the specified user in a game. On success, if the message was
// sent by the bot, returns the edited Message, otherwise returns True. Returns an error, if the
// new score is not greater than the user's current score in the chat and force is False.
func (api *API) SetGameScore(args *SetGameScore) (*Message, *Response, error) {
	resp, err := api.MakeRequest("setGameScore", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// SetMyCommands
// Use this method to change the list of the bot's commands. Returns True on success.
func (api *API) SetMyCommands(commands []BotCommand) (*Response, error) {
	args := map[string]interface{}{
		// A JSON-serialized list of bot commands to be set as the list of the bot's commands. At most
		// 100 commands can be specified.
		"commands": commands,
	}
	return api.MakeRequest("setMyCommands", args)
}

// SetPassportDataErrors
// Informs a user that some of the Telegram Passport elements they provided contains errors. The
// user will not be able to re-submit their Passport to you until the errors are fixed (the
// contents of the field for which you returned the error must change). Returns True on success.
func (api *API) SetPassportDataErrors(errors []PassportElementError, userID int64) (*Response, error) {
	args := map[string]interface{}{
		// A JSON-serialized array describing the errors
		"errors": errors,
		// User identifier
		"user_id": userID,
	}
	return api.MakeRequest("setPassportDataErrors", args)
}

// SetStickerPositionInSet
// Use this method to move a sticker in a set created by the bot to a specific position. Returns
// True on success.
func (api *API) SetStickerPositionInSet(position int64, sticker string) (*Response, error) {
	args := map[string]interface{}{
		// New sticker position in the set, zero-based
		"position": position,
		// File identifier of the sticker
		"sticker": sticker,
	}
	return api.MakeRequest("setStickerPositionInSet", args)
}

// SetStickerSetThumb
// Use this method to set the thumbnail of a sticker set. Animated thumbnails can be set for
// animated sticker sets only. Returns True on success.
func (api *API) SetStickerSetThumb(args *SetStickerSetThumb) (*Response, error) {
	return api.MakeRequest("setStickerSetThumb", args)
}

// SetWebhook
// Use this method to specify a url and receive incoming updates via an outgoing webhook. Whenever
// there is an update for the bot, we will send an HTTPS POST request to the specified url,
// containing a JSON-serialized Update. In case of an unsuccessful request, we will give up after a
// reasonable amount of attempts. Returns True on success.
func (api *API) SetWebhook(args *SetWebhook) (*Response, error) {
	return api.MakeRequest("setWebhook", args)
}

// StopMessageLiveLocation
// Use this method to stop updating a live location message before live_period expires. On success,
// if the message was sent by the bot, the sent Message is returned, otherwise True is returned.
func (api *API) StopMessageLiveLocation(args *StopMessageLiveLocation) (*Message, *Response, error) {
	resp, err := api.MakeRequest("stopMessageLiveLocation", args)
	if err != nil {
		return nil, resp, err
	}
	var data Message
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// StopPoll
// Use this method to stop a poll which was sent by the bot. On success, the stopped Poll with the
// final results is returned.
func (api *API) StopPoll(args *StopPoll) (*Poll, *Response, error) {
	resp, err := api.MakeRequest("stopPoll", args)
	if err != nil {
		return nil, resp, err
	}
	var data Poll
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}

// UnbanChatMember
// Use this method to unban a previously kicked user in a supergroup or channel. The user will not
// return to the group or channel automatically, but will be able to join via link, etc. The bot
// must be an administrator for this to work. Returns True on success.
func (api *API) UnbanChatMember(chatID IntStr, userID int64) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target group or username of the target supergroup or channel (in
		// the format @username)
		"chat_id": chatID,
		// Unique identifier of the target user
		"user_id": userID,
	}
	return api.MakeRequest("unbanChatMember", args)
}

// UnpinChatMessage
// Use this method to unpin a message in a group, a supergroup, or a channel. The bot must be an
// administrator in the chat for this to work and must have the 'can_pin_messages' admin right in
// the supergroup or 'can_edit_messages' admin right in the channel. Returns True on success.
func (api *API) UnpinChatMessage(chatID IntStr) (*Response, error) {
	args := map[string]interface{}{
		// Unique identifier for the target chat or username of the target channel (in the format
		// @channelusername)
		"chat_id": chatID,
	}
	return api.MakeRequest("unpinChatMessage", args)
}

// UploadStickerFile
// Use this method to upload a .PNG file with a sticker for later use in createNewStickerSet and
// addStickerToSet methods (can be used multiple times). Returns the uploaded File on success.
func (api *API) UploadStickerFile(pngSticker InputFile, userID int64) (*File, *Response, error) {
	args := map[string]interface{}{
		// PNG image with the sticker, must be up to 512 kilobytes in size, dimensions must not exceed
		// 512px, and either width or height must be exactly 512px.
		"png_sticker": pngSticker,
		// User identifier of sticker file owner
		"user_id": userID,
	}
	resp, err := api.MakeRequest("uploadStickerFile", args)
	if err != nil {
		return nil, resp, err
	}
	var data File
	err = json.Unmarshal(resp.Result, &data)
	return &data, resp, err
}
